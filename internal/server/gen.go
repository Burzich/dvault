// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// Defines values for TokenListAccessorsParamsList.
const (
	TokenListAccessorsParamsListTrue TokenListAccessorsParamsList = "true"
)

// Defines values for TokenListRolesParamsList.
const (
	TokenListRolesParamsListTrue TokenListRolesParamsList = "true"
)

// Defines values for KvV2ListParamsList.
const (
	True KvV2ListParamsList = "true"
)

// AuthEnableMethodRequest defines model for AuthEnableMethodRequest.
type AuthEnableMethodRequest struct {
	// Config Configuration for this mount, such as plugin_name.
	Config *map[string]interface{} `json:"config,omitempty"`

	// Description User-friendly description for this credential backend.
	Description *string `json:"description,omitempty"`

	// ExternalEntropyAccess Whether to give the mount access to Vault's external entropy.
	ExternalEntropyAccess *bool `json:"external_entropy_access,omitempty"`

	// Local Mark the mount as a local mount, which is not replicated and is unaffected by replication.
	Local *bool `json:"local,omitempty"`

	// Options The options to pass into the backend. Should be a json object with string keys and values.
	Options *map[string]interface{} `json:"options,omitempty"`

	// PluginName Name of the auth plugin to use based from the name in the plugin catalog.
	PluginName *string `json:"plugin_name,omitempty"`

	// PluginVersion The semantic version of the plugin to use, or image tag if oci_image is provided.
	PluginVersion *string `json:"plugin_version,omitempty"`

	// SealWrap Whether to turn on seal wrapping for the mount.
	SealWrap *bool `json:"seal_wrap,omitempty"`

	// Type The type of the backend. Example: "userpass"
	Type *string `json:"type,omitempty"`
}

// AuthReadConfigurationResponse defines model for AuthReadConfigurationResponse.
type AuthReadConfigurationResponse struct {
	Accessor              *string                 `json:"accessor,omitempty"`
	Config                *map[string]interface{} `json:"config,omitempty"`
	DeprecationStatus     *string                 `json:"deprecation_status,omitempty"`
	Description           *string                 `json:"description,omitempty"`
	ExternalEntropyAccess *bool                   `json:"external_entropy_access,omitempty"`
	Local                 *bool                   `json:"local,omitempty"`
	Options               *map[string]interface{} `json:"options,omitempty"`
	PluginVersion         *string                 `json:"plugin_version,omitempty"`
	RunningPluginVersion  *string                 `json:"running_plugin_version,omitempty"`
	RunningSha256         *string                 `json:"running_sha256,omitempty"`
	SealWrap              *bool                   `json:"seal_wrap,omitempty"`
	Type                  *string                 `json:"type,omitempty"`
	Uuid                  *string                 `json:"uuid,omitempty"`
}

// CollectHostInformationResponse defines model for CollectHostInformationResponse.
type CollectHostInformationResponse struct {
	Cpu       *[]map[string]interface{} `json:"cpu,omitempty"`
	CpuTimes  *[]map[string]interface{} `json:"cpu_times,omitempty"`
	Disk      *[]map[string]interface{} `json:"disk,omitempty"`
	Host      *map[string]interface{}   `json:"host,omitempty"`
	Memory    *map[string]interface{}   `json:"memory,omitempty"`
	Timestamp *time.Time                `json:"timestamp,omitempty"`
}

// DecodeTokenRequest defines model for DecodeTokenRequest.
type DecodeTokenRequest struct {
	// EncodedToken Specifies the encoded token (result from generate-root).
	EncodedToken *string `json:"encoded_token,omitempty"`

	// Otp Specifies the otp code for decode.
	Otp *string `json:"otp,omitempty"`
}

// GenerateHashRequest defines model for GenerateHashRequest.
type GenerateHashRequest struct {
	// Algorithm Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to "sha2-256".
	Algorithm *string `json:"algorithm,omitempty"`

	// Format Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
	Format *string `json:"format,omitempty"`

	// Input The base64-encoded input data
	Input *string `json:"input,omitempty"`
}

// GenerateHashResponse defines model for GenerateHashResponse.
type GenerateHashResponse struct {
	Sum *string `json:"sum,omitempty"`
}

// GenerateHashWithAlgorithmRequest defines model for GenerateHashWithAlgorithmRequest.
type GenerateHashWithAlgorithmRequest struct {
	// Algorithm Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to "sha2-256".
	Algorithm *string `json:"algorithm,omitempty"`

	// Format Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
	Format *string `json:"format,omitempty"`

	// Input The base64-encoded input data
	Input *string `json:"input,omitempty"`
}

// GenerateHashWithAlgorithmResponse defines model for GenerateHashWithAlgorithmResponse.
type GenerateHashWithAlgorithmResponse struct {
	Sum *string `json:"sum,omitempty"`
}

// GenerateRandomRequest defines model for GenerateRandomRequest.
type GenerateRandomRequest struct {
	// Bytes The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
	Bytes *int `json:"bytes,omitempty"`

	// Format Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
	Format *string `json:"format,omitempty"`
}

// GenerateRandomResponse defines model for GenerateRandomResponse.
type GenerateRandomResponse struct {
	RandomBytes *string `json:"random_bytes,omitempty"`
}

// GenerateRandomWithBytesRequest defines model for GenerateRandomWithBytesRequest.
type GenerateRandomWithBytesRequest struct {
	// Bytes The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
	Bytes *int `json:"bytes,omitempty"`

	// Format Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
	Format *string `json:"format,omitempty"`
}

// GenerateRandomWithBytesResponse defines model for GenerateRandomWithBytesResponse.
type GenerateRandomWithBytesResponse struct {
	RandomBytes *string `json:"random_bytes,omitempty"`
}

// GenerateRandomWithSourceAndBytesRequest defines model for GenerateRandomWithSourceAndBytesRequest.
type GenerateRandomWithSourceAndBytesRequest struct {
	// Bytes The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
	Bytes *int `json:"bytes,omitempty"`

	// Format Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
	Format *string `json:"format,omitempty"`
}

// GenerateRandomWithSourceAndBytesResponse defines model for GenerateRandomWithSourceAndBytesResponse.
type GenerateRandomWithSourceAndBytesResponse struct {
	RandomBytes *string `json:"random_bytes,omitempty"`
}

// GenerateRandomWithSourceRequest defines model for GenerateRandomWithSourceRequest.
type GenerateRandomWithSourceRequest struct {
	// Bytes The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
	Bytes *int `json:"bytes,omitempty"`

	// Format Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
	Format *string `json:"format,omitempty"`
}

// GenerateRandomWithSourceResponse defines model for GenerateRandomWithSourceResponse.
type GenerateRandomWithSourceResponse struct {
	RandomBytes *string `json:"random_bytes,omitempty"`
}

// KvV2ConfigureRequest defines model for KvV2ConfigureRequest.
type KvV2ConfigureRequest struct {
	// CasRequired If true, the backend will require the cas parameter to be set for each write
	CasRequired *bool `json:"cas_required,omitempty"`

	// DeleteVersionAfter If set, the length of time before a version is deleted. A negative duration disables the use of delete_version_after on all keys. A zero duration clears the current setting. Accepts a Go duration format string.
	DeleteVersionAfter *string `json:"delete_version_after,omitempty"`

	// MaxVersions The number of versions to keep for each key. Defaults to 10
	MaxVersions *int `json:"max_versions,omitempty"`
}

// KvV2DeleteVersionsRequest defines model for KvV2DeleteVersionsRequest.
type KvV2DeleteVersionsRequest struct {
	// Versions The versions to be archived. The versioned data will not be deleted, but it will no longer be returned in normal get requests.
	Versions *[]int `json:"versions,omitempty"`
}

// KvV2DestroyVersionsRequest defines model for KvV2DestroyVersionsRequest.
type KvV2DestroyVersionsRequest struct {
	// Versions The versions to destroy. Their data will be permanently deleted.
	Versions *[]int `json:"versions,omitempty"`
}

// KvV2ReadConfigurationResponse defines model for KvV2ReadConfigurationResponse.
type KvV2ReadConfigurationResponse struct {
	// CasRequired If true, the backend will require the cas parameter to be set for each write
	CasRequired *bool `json:"cas_required,omitempty"`

	// DeleteVersionAfter The length of time before a version is deleted.
	DeleteVersionAfter *string `json:"delete_version_after,omitempty"`

	// MaxVersions The number of versions to keep for each key.
	MaxVersions *int `json:"max_versions,omitempty"`
}

// KvV2ReadMetadataResponse defines model for KvV2ReadMetadataResponse.
type KvV2ReadMetadataResponse struct {
	CasRequired    *bool      `json:"cas_required,omitempty"`
	CreatedTime    *time.Time `json:"created_time,omitempty"`
	CurrentVersion *int64     `json:"current_version,omitempty"`

	// CustomMetadata User-provided key-value pairs that are used to describe arbitrary and version-agnostic information about a secret.
	CustomMetadata *map[string]interface{} `json:"custom_metadata,omitempty"`

	// DeleteVersionAfter The length of time before a version is deleted.
	DeleteVersionAfter *string `json:"delete_version_after,omitempty"`

	// MaxVersions The number of versions to keep
	MaxVersions   *int64                  `json:"max_versions,omitempty"`
	OldestVersion *int64                  `json:"oldest_version,omitempty"`
	UpdatedTime   *time.Time              `json:"updated_time,omitempty"`
	Versions      *map[string]interface{} `json:"versions,omitempty"`
}

// KvV2ReadResponse defines model for KvV2ReadResponse.
type KvV2ReadResponse struct {
	Data     *map[string]interface{} `json:"data,omitempty"`
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// KvV2ReadSubkeysResponse defines model for KvV2ReadSubkeysResponse.
type KvV2ReadSubkeysResponse struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Subkeys  *map[string]interface{} `json:"subkeys,omitempty"`
}

// KvV2UndeleteVersionsRequest defines model for KvV2UndeleteVersionsRequest.
type KvV2UndeleteVersionsRequest struct {
	// Versions The versions to unarchive. The versions will be restored and their data will be returned on normal get requests.
	Versions *[]int `json:"versions,omitempty"`
}

// KvV2WriteMetadataRequest defines model for KvV2WriteMetadataRequest.
type KvV2WriteMetadataRequest struct {
	// CasRequired If true the key will require the cas parameter to be set on all write requests. If false, the backend’s configuration will be used.
	CasRequired *bool `json:"cas_required,omitempty"`

	// CustomMetadata User-provided key-value pairs that are used to describe arbitrary and version-agnostic information about a secret.
	CustomMetadata *map[string]interface{} `json:"custom_metadata,omitempty"`

	// DeleteVersionAfter The length of time before a version is deleted. If not set, the backend's configured delete_version_after is used. Cannot be greater than the backend's delete_version_after. A zero duration clears the current setting. A negative duration will cause an error.
	DeleteVersionAfter *string `json:"delete_version_after,omitempty"`

	// MaxVersions The number of versions to keep. If not set, the backend’s configured max version is used.
	MaxVersions *int `json:"max_versions,omitempty"`
}

// KvV2WriteRequest defines model for KvV2WriteRequest.
type KvV2WriteRequest struct {
	// Data The contents of the data map will be stored and returned on read.
	Data *map[string]interface{} `json:"data,omitempty"`

	// Options Options for writing a KV entry. Set the "cas" value to use a Check-And-Set operation. If not set the write will be allowed. If set to 0 a write will only be allowed if the key doesn’t exist. If the index is non-zero the write will only be allowed if the key’s current version matches the version specified in the cas parameter.
	Options *map[string]interface{} `json:"options,omitempty"`

	// Version If provided during a read, the value at the version number will be returned
	Version *int `json:"version,omitempty"`
}

// KvV2WriteResponse defines model for KvV2WriteResponse.
type KvV2WriteResponse struct {
	CreatedTime    *time.Time              `json:"created_time,omitempty"`
	CustomMetadata *map[string]interface{} `json:"custom_metadata,omitempty"`
	DeletionTime   *string                 `json:"deletion_time,omitempty"`
	Destroyed      *bool                   `json:"destroyed,omitempty"`
	Version        *int64                  `json:"version,omitempty"`
}

// SealStatusResponse defines model for SealStatusResponse.
type SealStatusResponse struct {
	BuildDate         *string `json:"build_date,omitempty"`
	ClusterId         *string `json:"cluster_id,omitempty"`
	ClusterName       *string `json:"cluster_name,omitempty"`
	HcpLinkResourceID *string `json:"hcp_link_resource_ID,omitempty"`
	HcpLinkStatus     *string `json:"hcp_link_status,omitempty"`
	Initialized       *bool   `json:"initialized,omitempty"`
	Migration         *bool   `json:"migration,omitempty"`
	N                 *int    `json:"n,omitempty"`
	Nonce             *string `json:"nonce,omitempty"`
	Progress          *int    `json:"progress,omitempty"`
	RecoverySeal      *bool   `json:"recovery_seal,omitempty"`
	Sealed            *bool   `json:"sealed,omitempty"`
	StorageType       *string `json:"storage_type,omitempty"`
	T                 *int    `json:"t,omitempty"`
	Type              *string `json:"type,omitempty"`
	Version           *string `json:"version,omitempty"`
}

// StandardListResponse defines model for StandardListResponse.
type StandardListResponse struct {
	Keys *[]string `json:"keys,omitempty"`
}

// TokenCreateAgainstRoleRequest defines model for TokenCreateAgainstRoleRequest.
type TokenCreateAgainstRoleRequest struct {
	// DisplayName Name to associate with this token
	DisplayName *string `json:"display_name,omitempty"`

	// EntityAlias Name of the entity alias to associate with this token
	EntityAlias *string `json:"entity_alias,omitempty"`

	// ExplicitMaxTtl Explicit Max TTL of this token
	ExplicitMaxTtl *string `json:"explicit_max_ttl,omitempty"`

	// Id Value for the token
	Id *string `json:"id,omitempty"`

	// Lease Use 'ttl' instead
	// Deprecated:
	Lease *string `json:"lease,omitempty"`

	// Meta Arbitrary key=value metadata to associate with the token
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// NoDefaultPolicy Do not include default policy for this token
	NoDefaultPolicy *bool `json:"no_default_policy,omitempty"`

	// NoParent Create the token with no parent
	NoParent *bool `json:"no_parent,omitempty"`

	// NumUses Max number of uses for this token
	NumUses *int `json:"num_uses,omitempty"`

	// Period Renew period
	Period *string `json:"period,omitempty"`

	// Policies List of policies for the token
	Policies *[]string `json:"policies,omitempty"`

	// Renewable Allow token to be renewed past its initial TTL up to system/mount maximum TTL
	Renewable *bool `json:"renewable,omitempty"`

	// Ttl Time to live for this token
	Ttl *string `json:"ttl,omitempty"`

	// Type Token type
	Type *string `json:"type,omitempty"`
}

// TokenCreateOrphanRequest defines model for TokenCreateOrphanRequest.
type TokenCreateOrphanRequest struct {
	// DisplayName Name to associate with this token
	DisplayName *string `json:"display_name,omitempty"`

	// EntityAlias Name of the entity alias to associate with this token
	EntityAlias *string `json:"entity_alias,omitempty"`

	// ExplicitMaxTtl Explicit Max TTL of this token
	ExplicitMaxTtl *string `json:"explicit_max_ttl,omitempty"`

	// Id Value for the token
	Id *string `json:"id,omitempty"`

	// Lease Use 'ttl' instead
	// Deprecated:
	Lease *string `json:"lease,omitempty"`

	// Meta Arbitrary key=value metadata to associate with the token
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// NoDefaultPolicy Do not include default policy for this token
	NoDefaultPolicy *bool `json:"no_default_policy,omitempty"`

	// NoParent Create the token with no parent
	NoParent *bool `json:"no_parent,omitempty"`

	// NumUses Max number of uses for this token
	NumUses *int `json:"num_uses,omitempty"`

	// Period Renew period
	Period *string `json:"period,omitempty"`

	// Policies List of policies for the token
	Policies *[]string `json:"policies,omitempty"`

	// Renewable Allow token to be renewed past its initial TTL up to system/mount maximum TTL
	Renewable *bool `json:"renewable,omitempty"`

	// Ttl Time to live for this token
	Ttl *string `json:"ttl,omitempty"`

	// Type Token type
	Type *string `json:"type,omitempty"`
}

// TokenCreateRequest defines model for TokenCreateRequest.
type TokenCreateRequest struct {
	// DisplayName Name to associate with this token
	DisplayName *string `json:"display_name,omitempty"`

	// EntityAlias Name of the entity alias to associate with this token
	EntityAlias *string `json:"entity_alias,omitempty"`

	// ExplicitMaxTtl Explicit Max TTL of this token
	ExplicitMaxTtl *string `json:"explicit_max_ttl,omitempty"`

	// Id Value for the token
	Id *string `json:"id,omitempty"`

	// Lease Use 'ttl' instead
	// Deprecated:
	Lease *string `json:"lease,omitempty"`

	// Meta Arbitrary key=value metadata to associate with the token
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// NoDefaultPolicy Do not include default policy for this token
	NoDefaultPolicy *bool `json:"no_default_policy,omitempty"`

	// NoParent Create the token with no parent
	NoParent *bool `json:"no_parent,omitempty"`

	// NumUses Max number of uses for this token
	NumUses *int `json:"num_uses,omitempty"`

	// Period Renew period
	Period *string `json:"period,omitempty"`

	// Policies List of policies for the token
	Policies *[]string `json:"policies,omitempty"`

	// Renewable Allow token to be renewed past its initial TTL up to system/mount maximum TTL
	Renewable *bool `json:"renewable,omitempty"`

	// Ttl Time to live for this token
	Ttl *string `json:"ttl,omitempty"`

	// Type Token type
	Type *string `json:"type,omitempty"`
}

// TokenLookUpAccessorRequest defines model for TokenLookUpAccessorRequest.
type TokenLookUpAccessorRequest struct {
	// Accessor Accessor of the token to look up (request body)
	Accessor *string `json:"accessor,omitempty"`
}

// TokenLookUpRequest defines model for TokenLookUpRequest.
type TokenLookUpRequest struct {
	// Token Token to lookup
	Token *string `json:"token,omitempty"`
}

// TokenLookUpSelf2Request defines model for TokenLookUpSelf2Request.
type TokenLookUpSelf2Request struct {
	// Token Token to look up (unused, does not need to be set)
	Token *string `json:"token,omitempty"`
}

// TokenRenewAccessorRequest defines model for TokenRenewAccessorRequest.
type TokenRenewAccessorRequest struct {
	// Accessor Accessor of the token to renew (request body)
	Accessor *string `json:"accessor,omitempty"`

	// Increment The desired increment in seconds to the token expiration
	Increment *string `json:"increment,omitempty"`
}

// TokenRenewRequest defines model for TokenRenewRequest.
type TokenRenewRequest struct {
	// Increment The desired increment in seconds to the token expiration
	Increment *string `json:"increment,omitempty"`

	// Token Token to renew (request body)
	Token *string `json:"token,omitempty"`
}

// TokenRenewSelfRequest defines model for TokenRenewSelfRequest.
type TokenRenewSelfRequest struct {
	// Increment The desired increment in seconds to the token expiration
	Increment *string `json:"increment,omitempty"`

	// Token Token to renew (unused, does not need to be set)
	Token *string `json:"token,omitempty"`
}

// TokenRevokeAccessorRequest defines model for TokenRevokeAccessorRequest.
type TokenRevokeAccessorRequest struct {
	// Accessor Accessor of the token (request body)
	Accessor *string `json:"accessor,omitempty"`
}

// TokenRevokeOrphanRequest defines model for TokenRevokeOrphanRequest.
type TokenRevokeOrphanRequest struct {
	// Token Token to revoke (request body)
	Token *string `json:"token,omitempty"`
}

// TokenRevokeRequest defines model for TokenRevokeRequest.
type TokenRevokeRequest struct {
	// Token Token to revoke (request body)
	Token *string `json:"token,omitempty"`
}

// TokenWriteRoleRequest defines model for TokenWriteRoleRequest.
type TokenWriteRoleRequest struct {
	// AllowedEntityAliases String or JSON list of allowed entity aliases. If set, specifies the entity aliases which are allowed to be used during token generation. This field supports globbing.
	AllowedEntityAliases *[]string `json:"allowed_entity_aliases,omitempty"`

	// AllowedPolicies If set, tokens can be created with any subset of the policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy names.
	AllowedPolicies *[]string `json:"allowed_policies,omitempty"`

	// AllowedPoliciesGlob If set, tokens can be created with any subset of glob matched policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy name globs.
	AllowedPoliciesGlob *[]string `json:"allowed_policies_glob,omitempty"`

	// BoundCidrs Use 'token_bound_cidrs' instead.
	// Deprecated:
	BoundCidrs *[]string `json:"bound_cidrs,omitempty"`

	// DisallowedPolicies If set, successful token creation via this role will require that no policies in the given list are requested. The parameter is a comma-delimited string of policy names.
	DisallowedPolicies *[]string `json:"disallowed_policies,omitempty"`

	// DisallowedPoliciesGlob If set, successful token creation via this role will require that no requested policies glob match any of policies in this list. The parameter is a comma-delimited string of policy name globs.
	DisallowedPoliciesGlob *[]string `json:"disallowed_policies_glob,omitempty"`

	// ExplicitMaxTtl Use 'token_explicit_max_ttl' instead.
	// Deprecated:
	ExplicitMaxTtl *string `json:"explicit_max_ttl,omitempty"`

	// Orphan If true, tokens created via this role will be orphan tokens (have no parent)
	Orphan *bool `json:"orphan,omitempty"`

	// PathSuffix If set, tokens created via this role will contain the given suffix as a part of their path. This can be used to assist use of the 'revoke-prefix' endpoint later on. The given suffix must match the regular expression.\w[\w-.]+\w
	PathSuffix *string `json:"path_suffix,omitempty"`

	// Period Use 'token_period' instead.
	// Deprecated:
	Period *string `json:"period,omitempty"`

	// Renewable Tokens created via this role will be renewable or not according to this value. Defaults to "true".
	Renewable *bool `json:"renewable,omitempty"`

	// TokenBoundCidrs Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.
	TokenBoundCidrs *[]string `json:"token_bound_cidrs,omitempty"`

	// TokenExplicitMaxTtl If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
	TokenExplicitMaxTtl *string `json:"token_explicit_max_ttl,omitempty"`

	// TokenNoDefaultPolicy If true, the 'default' policy will not automatically be added to generated tokens
	TokenNoDefaultPolicy *bool `json:"token_no_default_policy,omitempty"`

	// TokenNumUses The maximum number of times a token may be used, a value of zero means unlimited
	TokenNumUses *int `json:"token_num_uses,omitempty"`

	// TokenPeriod If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
	TokenPeriod *string `json:"token_period,omitempty"`

	// TokenType The type of token to generate, service or batch
	TokenType *string `json:"token_type,omitempty"`
}

// UnsealRequest defines model for UnsealRequest.
type UnsealRequest struct {
	// Key Specifies a single unseal key share. This is required unless reset is true.
	Key *string `json:"key,omitempty"`

	// Migrate Used to migrate the seal from shamir to autoseal or autoseal to shamir. Must be provided on all unseal key calls.
	Migrate *bool `json:"migrate,omitempty"`

	// Reset Specifies if previously-provided unseal keys are discarded and the unseal process is reset.
	Reset *bool `json:"reset,omitempty"`
}

// UnsealResponse defines model for UnsealResponse.
type UnsealResponse struct {
	BuildDate         *string `json:"build_date,omitempty"`
	ClusterId         *string `json:"cluster_id,omitempty"`
	ClusterName       *string `json:"cluster_name,omitempty"`
	HcpLinkResourceID *string `json:"hcp_link_resource_ID,omitempty"`
	HcpLinkStatus     *string `json:"hcp_link_status,omitempty"`
	Initialized       *bool   `json:"initialized,omitempty"`
	Migration         *bool   `json:"migration,omitempty"`
	N                 *int    `json:"n,omitempty"`
	Nonce             *string `json:"nonce,omitempty"`
	Progress          *int    `json:"progress,omitempty"`
	RecoverySeal      *bool   `json:"recovery_seal,omitempty"`
	Sealed            *bool   `json:"sealed,omitempty"`
	StorageType       *string `json:"storage_type,omitempty"`
	T                 *int    `json:"t,omitempty"`
	Type              *string `json:"type,omitempty"`
	Version           *string `json:"version,omitempty"`
}

// TokenListAccessorsParams defines parameters for TokenListAccessors.
type TokenListAccessorsParams struct {
	// List Must be set to `true`
	List TokenListAccessorsParamsList `form:"list" json:"list"`
}

// TokenListAccessorsParamsList defines parameters for TokenListAccessors.
type TokenListAccessorsParamsList string

// TokenLookUp2Params defines parameters for TokenLookUp2.
type TokenLookUp2Params struct {
	// Token Token to lookup
	Token *string `form:"token,omitempty" json:"token,omitempty"`
}

// TokenListRolesParams defines parameters for TokenListRoles.
type TokenListRolesParams struct {
	// List Must be set to `true`
	List TokenListRolesParamsList `form:"list" json:"list"`
}

// TokenListRolesParamsList defines parameters for TokenListRoles.
type TokenListRolesParamsList string

// KvV2ListParams defines parameters for KvV2List.
type KvV2ListParams struct {
	// List Must be set to `true`
	List KvV2ListParamsList `form:"list" json:"list"`
}

// KvV2ListParamsList defines parameters for KvV2List.
type KvV2ListParamsList string

// TokenCreateJSONRequestBody defines body for TokenCreate for application/json ContentType.
type TokenCreateJSONRequestBody = TokenCreateRequest

// TokenCreateOrphanJSONRequestBody defines body for TokenCreateOrphan for application/json ContentType.
type TokenCreateOrphanJSONRequestBody = TokenCreateOrphanRequest

// TokenCreateAgainstRoleJSONRequestBody defines body for TokenCreateAgainstRole for application/json ContentType.
type TokenCreateAgainstRoleJSONRequestBody = TokenCreateAgainstRoleRequest

// TokenLookUpJSONRequestBody defines body for TokenLookUp for application/json ContentType.
type TokenLookUpJSONRequestBody = TokenLookUpRequest

// TokenLookUpAccessorJSONRequestBody defines body for TokenLookUpAccessor for application/json ContentType.
type TokenLookUpAccessorJSONRequestBody = TokenLookUpAccessorRequest

// TokenLookUpSelf2JSONRequestBody defines body for TokenLookUpSelf2 for application/json ContentType.
type TokenLookUpSelf2JSONRequestBody = TokenLookUpSelf2Request

// TokenRenewJSONRequestBody defines body for TokenRenew for application/json ContentType.
type TokenRenewJSONRequestBody = TokenRenewRequest

// TokenRenewAccessorJSONRequestBody defines body for TokenRenewAccessor for application/json ContentType.
type TokenRenewAccessorJSONRequestBody = TokenRenewAccessorRequest

// TokenRenewSelfJSONRequestBody defines body for TokenRenewSelf for application/json ContentType.
type TokenRenewSelfJSONRequestBody = TokenRenewSelfRequest

// TokenRevokeJSONRequestBody defines body for TokenRevoke for application/json ContentType.
type TokenRevokeJSONRequestBody = TokenRevokeRequest

// TokenRevokeAccessorJSONRequestBody defines body for TokenRevokeAccessor for application/json ContentType.
type TokenRevokeAccessorJSONRequestBody = TokenRevokeAccessorRequest

// TokenRevokeOrphanJSONRequestBody defines body for TokenRevokeOrphan for application/json ContentType.
type TokenRevokeOrphanJSONRequestBody = TokenRevokeOrphanRequest

// TokenWriteRoleJSONRequestBody defines body for TokenWriteRole for application/json ContentType.
type TokenWriteRoleJSONRequestBody = TokenWriteRoleRequest

// KvV2ConfigureJSONRequestBody defines body for KvV2Configure for application/json ContentType.
type KvV2ConfigureJSONRequestBody = KvV2ConfigureRequest

// KvV2WriteJSONRequestBody defines body for KvV2Write for application/json ContentType.
type KvV2WriteJSONRequestBody = KvV2WriteRequest

// KvV2DeleteVersionsJSONRequestBody defines body for KvV2DeleteVersions for application/json ContentType.
type KvV2DeleteVersionsJSONRequestBody = KvV2DeleteVersionsRequest

// KvV2DestroyVersionsJSONRequestBody defines body for KvV2DestroyVersions for application/json ContentType.
type KvV2DestroyVersionsJSONRequestBody = KvV2DestroyVersionsRequest

// KvV2WriteMetadataJSONRequestBody defines body for KvV2WriteMetadata for application/json ContentType.
type KvV2WriteMetadataJSONRequestBody = KvV2WriteMetadataRequest

// KvV2UndeleteVersionsJSONRequestBody defines body for KvV2UndeleteVersions for application/json ContentType.
type KvV2UndeleteVersionsJSONRequestBody = KvV2UndeleteVersionsRequest

// AuthEnableMethodJSONRequestBody defines body for AuthEnableMethod for application/json ContentType.
type AuthEnableMethodJSONRequestBody = AuthEnableMethodRequest

// DecodeTokenJSONRequestBody defines body for DecodeToken for application/json ContentType.
type DecodeTokenJSONRequestBody = DecodeTokenRequest

// GenerateHashJSONRequestBody defines body for GenerateHash for application/json ContentType.
type GenerateHashJSONRequestBody = GenerateHashRequest

// GenerateHashWithAlgorithmJSONRequestBody defines body for GenerateHashWithAlgorithm for application/json ContentType.
type GenerateHashWithAlgorithmJSONRequestBody = GenerateHashWithAlgorithmRequest

// GenerateRandomJSONRequestBody defines body for GenerateRandom for application/json ContentType.
type GenerateRandomJSONRequestBody = GenerateRandomRequest

// GenerateRandomWithSourceJSONRequestBody defines body for GenerateRandomWithSource for application/json ContentType.
type GenerateRandomWithSourceJSONRequestBody = GenerateRandomWithSourceRequest

// GenerateRandomWithSourceAndBytesJSONRequestBody defines body for GenerateRandomWithSourceAndBytes for application/json ContentType.
type GenerateRandomWithSourceAndBytesJSONRequestBody = GenerateRandomWithSourceAndBytesRequest

// GenerateRandomWithBytesJSONRequestBody defines body for GenerateRandomWithBytes for application/json ContentType.
type GenerateRandomWithBytesJSONRequestBody = GenerateRandomWithBytesRequest

// UnsealJSONRequestBody defines body for Unseal for application/json ContentType.
type UnsealJSONRequestBody = UnsealRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List token accessors, which can then be
	// be used to iterate and discover their properties
	// or revoke them. Because this can be used to
	// cause a denial of service, this endpoint
	// requires 'sudo' capability in addition to
	// 'list'.
	// (GET /auth/token/accessors/)
	TokenListAccessors(w http.ResponseWriter, r *http.Request, params TokenListAccessorsParams)
	// The token create path is used to create new tokens.
	// (POST /auth/token/create)
	TokenCreate(w http.ResponseWriter, r *http.Request)
	// The token create path is used to create new orphan tokens.
	// (POST /auth/token/create-orphan)
	TokenCreateOrphan(w http.ResponseWriter, r *http.Request)
	// This token create path is used to create new tokens adhering to the given role.
	// (POST /auth/token/create/{role_name})
	TokenCreateAgainstRole(w http.ResponseWriter, r *http.Request, roleName string)

	// (GET /auth/token/lookup)
	TokenLookUp2(w http.ResponseWriter, r *http.Request, params TokenLookUp2Params)

	// (POST /auth/token/lookup)
	TokenLookUp(w http.ResponseWriter, r *http.Request)
	// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
	// (POST /auth/token/lookup-accessor)
	TokenLookUpAccessor(w http.ResponseWriter, r *http.Request)

	// (GET /auth/token/lookup-self)
	TokenLookUpSelf(w http.ResponseWriter, r *http.Request)

	// (POST /auth/token/lookup-self)
	TokenLookUpSelf2(w http.ResponseWriter, r *http.Request)
	// This endpoint will renew the given token and prevent expiration.
	// (POST /auth/token/renew)
	TokenRenew(w http.ResponseWriter, r *http.Request)
	// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
	// (POST /auth/token/renew-accessor)
	TokenRenewAccessor(w http.ResponseWriter, r *http.Request)
	// This endpoint will renew the token used to call it and prevent expiration.
	// (POST /auth/token/renew-self)
	TokenRenewSelf(w http.ResponseWriter, r *http.Request)
	// This endpoint will delete the given token and all of its child tokens.
	// (POST /auth/token/revoke)
	TokenRevoke(w http.ResponseWriter, r *http.Request)
	// This endpoint will delete the token associated with the accessor and all of its child tokens.
	// (POST /auth/token/revoke-accessor)
	TokenRevokeAccessor(w http.ResponseWriter, r *http.Request)
	// This endpoint will delete the token and orphan its child tokens.
	// (POST /auth/token/revoke-orphan)
	TokenRevokeOrphan(w http.ResponseWriter, r *http.Request)
	// This endpoint will delete the token used to call it and all of its child tokens.
	// (POST /auth/token/revoke-self)
	TokenRevokeSelf(w http.ResponseWriter, r *http.Request)
	// This endpoint lists configured roles.
	// (GET /auth/token/roles/)
	TokenListRoles(w http.ResponseWriter, r *http.Request, params TokenListRolesParams)

	// (DELETE /auth/token/roles/{role_name})
	TokenDeleteRole(w http.ResponseWriter, r *http.Request, roleName string)

	// (GET /auth/token/roles/{role_name})
	TokenReadRole(w http.ResponseWriter, r *http.Request, roleName string)

	// (POST /auth/token/roles/{role_name})
	TokenWriteRole(w http.ResponseWriter, r *http.Request, roleName string)
	// Read the backend level settings.
	// (GET /secret/config)
	KvV2ReadConfiguration(w http.ResponseWriter, r *http.Request)
	// Configure backend level settings that are applied to every key in the key-value store.
	// (POST /secret/config)
	KvV2Configure(w http.ResponseWriter, r *http.Request)

	// (DELETE /secret/data/{path})
	KvV2Delete(w http.ResponseWriter, r *http.Request, path string)

	// (GET /secret/data/{path})
	KvV2Read(w http.ResponseWriter, r *http.Request, path string)

	// (POST /secret/data/{path})
	KvV2Write(w http.ResponseWriter, r *http.Request, path string)

	// (POST /secret/delete/{path})
	KvV2DeleteVersions(w http.ResponseWriter, r *http.Request, path string)

	// (POST /secret/destroy/{path})
	KvV2DestroyVersions(w http.ResponseWriter, r *http.Request, path string)

	// (DELETE /secret/metadata/{path})
	KvV2DeleteMetadataAndAllVersions(w http.ResponseWriter, r *http.Request, path string)

	// (GET /secret/metadata/{path})
	KvV2ReadMetadata(w http.ResponseWriter, r *http.Request, path string)

	// (POST /secret/metadata/{path})
	KvV2WriteMetadata(w http.ResponseWriter, r *http.Request, path string)

	// (GET /secret/metadata/{path}/)
	KvV2List(w http.ResponseWriter, r *http.Request, path string, params KvV2ListParams)

	// (GET /secret/subkeys/{path})
	KvV2ReadSubkeys(w http.ResponseWriter, r *http.Request, path string)

	// (POST /secret/undelete/{path})
	KvV2UndeleteVersions(w http.ResponseWriter, r *http.Request, path string)

	// (GET /sys/auth)
	AuthListEnabledMethods(w http.ResponseWriter, r *http.Request)
	// Disable the auth method at the given auth path
	// (DELETE /sys/auth/{path})
	AuthDisableMethod(w http.ResponseWriter, r *http.Request, path string)
	// Read the configuration of the auth engine at the given path.
	// (GET /sys/auth/{path})
	AuthReadConfiguration(w http.ResponseWriter, r *http.Request, path string)
	// Enables a new auth method.
	// (POST /sys/auth/{path})
	AuthEnableMethod(w http.ResponseWriter, r *http.Request, path string)
	// Decodes the encoded token with the otp.
	// (POST /sys/decode-token)
	DecodeToken(w http.ResponseWriter, r *http.Request)
	// Returns the health status of Vault.
	// (GET /sys/health)
	ReadHealthStatus(w http.ResponseWriter, r *http.Request)
	// Information about the host instance that this Vault server is running on.
	// (GET /sys/host-info)
	CollectHostInformation(w http.ResponseWriter, r *http.Request)
	// Returns an HTML page listing the available profiles.
	// (GET /sys/pprof)
	PprofIndex(w http.ResponseWriter, r *http.Request)
	// Returns a sampling of all past memory allocations.
	// (GET /sys/pprof/allocs)
	PprofMemoryAllocations(w http.ResponseWriter, r *http.Request)
	// Returns stack traces that led to blocking on synchronization primitives
	// (GET /sys/pprof/block)
	PprofBlocking(w http.ResponseWriter, r *http.Request)
	// Returns the running program's command line.
	// (GET /sys/pprof/cmdline)
	PprofCommandLine(w http.ResponseWriter, r *http.Request)
	// Returns stack traces of all current goroutines.
	// (GET /sys/pprof/goroutine)
	PprofGoroutines(w http.ResponseWriter, r *http.Request)
	// Returns a sampling of memory allocations of live object.
	// (GET /sys/pprof/heap)
	PprofMemoryAllocationsLive(w http.ResponseWriter, r *http.Request)
	// Returns stack traces of holders of contended mutexes
	// (GET /sys/pprof/mutex)
	PprofMutexes(w http.ResponseWriter, r *http.Request)
	// Returns a pprof-formatted cpu profile payload.
	// (GET /sys/pprof/profile)
	PprofCpuProfile(w http.ResponseWriter, r *http.Request)
	// Returns the program counters listed in the request.
	// (GET /sys/pprof/symbol)
	PprofSymbols(w http.ResponseWriter, r *http.Request)
	// Returns stack traces that led to the creation of new OS threads
	// (GET /sys/pprof/threadcreate)
	PprofThreadCreations(w http.ResponseWriter, r *http.Request)
	// Returns the execution trace in binary form.
	// (GET /sys/pprof/trace)
	PprofExecutionTrace(w http.ResponseWriter, r *http.Request)
	// Seal the Vault.
	// (POST /sys/seal)
	Seal(w http.ResponseWriter, r *http.Request)
	// Check the seal status of a Vault.
	// (GET /sys/seal-status)
	SealStatus(w http.ResponseWriter, r *http.Request)

	// (POST /sys/tools/hash)
	GenerateHash(w http.ResponseWriter, r *http.Request)

	// (POST /sys/tools/hash/{urlalgorithm})
	GenerateHashWithAlgorithm(w http.ResponseWriter, r *http.Request, urlalgorithm string)

	// (POST /sys/tools/random)
	GenerateRandom(w http.ResponseWriter, r *http.Request)

	// (POST /sys/tools/random/{source})
	GenerateRandomWithSource(w http.ResponseWriter, r *http.Request, source string)

	// (POST /sys/tools/random/{source}/{urlbytes})
	GenerateRandomWithSourceAndBytes(w http.ResponseWriter, r *http.Request, source string, urlbytes string)

	// (POST /sys/tools/random/{urlbytes})
	GenerateRandomWithBytes(w http.ResponseWriter, r *http.Request, urlbytes string)
	// Unseal the Vault.
	// (POST /sys/unseal)
	Unseal(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List token accessors, which can then be
// be used to iterate and discover their properties
// or revoke them. Because this can be used to
// cause a denial of service, this endpoint
// requires 'sudo' capability in addition to
// 'list'.
// (GET /auth/token/accessors/)
func (_ Unimplemented) TokenListAccessors(w http.ResponseWriter, r *http.Request, params TokenListAccessorsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// The token create path is used to create new tokens.
// (POST /auth/token/create)
func (_ Unimplemented) TokenCreate(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// The token create path is used to create new orphan tokens.
// (POST /auth/token/create-orphan)
func (_ Unimplemented) TokenCreateOrphan(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This token create path is used to create new tokens adhering to the given role.
// (POST /auth/token/create/{role_name})
func (_ Unimplemented) TokenCreateAgainstRole(w http.ResponseWriter, r *http.Request, roleName string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /auth/token/lookup)
func (_ Unimplemented) TokenLookUp2(w http.ResponseWriter, r *http.Request, params TokenLookUp2Params) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /auth/token/lookup)
func (_ Unimplemented) TokenLookUp(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
// (POST /auth/token/lookup-accessor)
func (_ Unimplemented) TokenLookUpAccessor(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /auth/token/lookup-self)
func (_ Unimplemented) TokenLookUpSelf(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /auth/token/lookup-self)
func (_ Unimplemented) TokenLookUpSelf2(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint will renew the given token and prevent expiration.
// (POST /auth/token/renew)
func (_ Unimplemented) TokenRenew(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
// (POST /auth/token/renew-accessor)
func (_ Unimplemented) TokenRenewAccessor(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint will renew the token used to call it and prevent expiration.
// (POST /auth/token/renew-self)
func (_ Unimplemented) TokenRenewSelf(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint will delete the given token and all of its child tokens.
// (POST /auth/token/revoke)
func (_ Unimplemented) TokenRevoke(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint will delete the token associated with the accessor and all of its child tokens.
// (POST /auth/token/revoke-accessor)
func (_ Unimplemented) TokenRevokeAccessor(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint will delete the token and orphan its child tokens.
// (POST /auth/token/revoke-orphan)
func (_ Unimplemented) TokenRevokeOrphan(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint will delete the token used to call it and all of its child tokens.
// (POST /auth/token/revoke-self)
func (_ Unimplemented) TokenRevokeSelf(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// This endpoint lists configured roles.
// (GET /auth/token/roles/)
func (_ Unimplemented) TokenListRoles(w http.ResponseWriter, r *http.Request, params TokenListRolesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (DELETE /auth/token/roles/{role_name})
func (_ Unimplemented) TokenDeleteRole(w http.ResponseWriter, r *http.Request, roleName string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /auth/token/roles/{role_name})
func (_ Unimplemented) TokenReadRole(w http.ResponseWriter, r *http.Request, roleName string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /auth/token/roles/{role_name})
func (_ Unimplemented) TokenWriteRole(w http.ResponseWriter, r *http.Request, roleName string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Read the backend level settings.
// (GET /secret/config)
func (_ Unimplemented) KvV2ReadConfiguration(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Configure backend level settings that are applied to every key in the key-value store.
// (POST /secret/config)
func (_ Unimplemented) KvV2Configure(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (DELETE /secret/data/{path})
func (_ Unimplemented) KvV2Delete(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /secret/data/{path})
func (_ Unimplemented) KvV2Read(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /secret/data/{path})
func (_ Unimplemented) KvV2Write(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /secret/delete/{path})
func (_ Unimplemented) KvV2DeleteVersions(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /secret/destroy/{path})
func (_ Unimplemented) KvV2DestroyVersions(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (DELETE /secret/metadata/{path})
func (_ Unimplemented) KvV2DeleteMetadataAndAllVersions(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /secret/metadata/{path})
func (_ Unimplemented) KvV2ReadMetadata(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /secret/metadata/{path})
func (_ Unimplemented) KvV2WriteMetadata(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /secret/metadata/{path}/)
func (_ Unimplemented) KvV2List(w http.ResponseWriter, r *http.Request, path string, params KvV2ListParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /secret/subkeys/{path})
func (_ Unimplemented) KvV2ReadSubkeys(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /secret/undelete/{path})
func (_ Unimplemented) KvV2UndeleteVersions(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /sys/auth)
func (_ Unimplemented) AuthListEnabledMethods(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Disable the auth method at the given auth path
// (DELETE /sys/auth/{path})
func (_ Unimplemented) AuthDisableMethod(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Read the configuration of the auth engine at the given path.
// (GET /sys/auth/{path})
func (_ Unimplemented) AuthReadConfiguration(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Enables a new auth method.
// (POST /sys/auth/{path})
func (_ Unimplemented) AuthEnableMethod(w http.ResponseWriter, r *http.Request, path string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Decodes the encoded token with the otp.
// (POST /sys/decode-token)
func (_ Unimplemented) DecodeToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns the health status of Vault.
// (GET /sys/health)
func (_ Unimplemented) ReadHealthStatus(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Information about the host instance that this Vault server is running on.
// (GET /sys/host-info)
func (_ Unimplemented) CollectHostInformation(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns an HTML page listing the available profiles.
// (GET /sys/pprof)
func (_ Unimplemented) PprofIndex(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns a sampling of all past memory allocations.
// (GET /sys/pprof/allocs)
func (_ Unimplemented) PprofMemoryAllocations(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns stack traces that led to blocking on synchronization primitives
// (GET /sys/pprof/block)
func (_ Unimplemented) PprofBlocking(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns the running program's command line.
// (GET /sys/pprof/cmdline)
func (_ Unimplemented) PprofCommandLine(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns stack traces of all current goroutines.
// (GET /sys/pprof/goroutine)
func (_ Unimplemented) PprofGoroutines(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns a sampling of memory allocations of live object.
// (GET /sys/pprof/heap)
func (_ Unimplemented) PprofMemoryAllocationsLive(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns stack traces of holders of contended mutexes
// (GET /sys/pprof/mutex)
func (_ Unimplemented) PprofMutexes(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns a pprof-formatted cpu profile payload.
// (GET /sys/pprof/profile)
func (_ Unimplemented) PprofCpuProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns the program counters listed in the request.
// (GET /sys/pprof/symbol)
func (_ Unimplemented) PprofSymbols(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns stack traces that led to the creation of new OS threads
// (GET /sys/pprof/threadcreate)
func (_ Unimplemented) PprofThreadCreations(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns the execution trace in binary form.
// (GET /sys/pprof/trace)
func (_ Unimplemented) PprofExecutionTrace(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Seal the Vault.
// (POST /sys/seal)
func (_ Unimplemented) Seal(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Check the seal status of a Vault.
// (GET /sys/seal-status)
func (_ Unimplemented) SealStatus(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sys/tools/hash)
func (_ Unimplemented) GenerateHash(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sys/tools/hash/{urlalgorithm})
func (_ Unimplemented) GenerateHashWithAlgorithm(w http.ResponseWriter, r *http.Request, urlalgorithm string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sys/tools/random)
func (_ Unimplemented) GenerateRandom(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sys/tools/random/{source})
func (_ Unimplemented) GenerateRandomWithSource(w http.ResponseWriter, r *http.Request, source string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sys/tools/random/{source}/{urlbytes})
func (_ Unimplemented) GenerateRandomWithSourceAndBytes(w http.ResponseWriter, r *http.Request, source string, urlbytes string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /sys/tools/random/{urlbytes})
func (_ Unimplemented) GenerateRandomWithBytes(w http.ResponseWriter, r *http.Request, urlbytes string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unseal the Vault.
// (POST /sys/unseal)
func (_ Unimplemented) Unseal(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// TokenListAccessors operation middleware
func (siw *ServerInterfaceWrapper) TokenListAccessors(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TokenListAccessorsParams

	// ------------- Required query parameter "list" -------------

	if paramValue := r.URL.Query().Get("list"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "list"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "list", r.URL.Query(), &params.List)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "list", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenListAccessors(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenCreate operation middleware
func (siw *ServerInterfaceWrapper) TokenCreate(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenCreate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenCreateOrphan operation middleware
func (siw *ServerInterfaceWrapper) TokenCreateOrphan(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenCreateOrphan(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenCreateAgainstRole operation middleware
func (siw *ServerInterfaceWrapper) TokenCreateAgainstRole(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "role_name" -------------
	var roleName string

	err = runtime.BindStyledParameterWithOptions("simple", "role_name", chi.URLParam(r, "role_name"), &roleName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role_name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenCreateAgainstRole(w, r, roleName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenLookUp2 operation middleware
func (siw *ServerInterfaceWrapper) TokenLookUp2(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TokenLookUp2Params

	// ------------- Optional query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, false, "token", r.URL.Query(), &params.Token)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenLookUp2(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenLookUp operation middleware
func (siw *ServerInterfaceWrapper) TokenLookUp(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenLookUp(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenLookUpAccessor operation middleware
func (siw *ServerInterfaceWrapper) TokenLookUpAccessor(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenLookUpAccessor(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenLookUpSelf operation middleware
func (siw *ServerInterfaceWrapper) TokenLookUpSelf(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenLookUpSelf(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenLookUpSelf2 operation middleware
func (siw *ServerInterfaceWrapper) TokenLookUpSelf2(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenLookUpSelf2(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenRenew operation middleware
func (siw *ServerInterfaceWrapper) TokenRenew(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenRenew(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenRenewAccessor operation middleware
func (siw *ServerInterfaceWrapper) TokenRenewAccessor(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenRenewAccessor(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenRenewSelf operation middleware
func (siw *ServerInterfaceWrapper) TokenRenewSelf(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenRenewSelf(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenRevoke operation middleware
func (siw *ServerInterfaceWrapper) TokenRevoke(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenRevoke(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenRevokeAccessor operation middleware
func (siw *ServerInterfaceWrapper) TokenRevokeAccessor(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenRevokeAccessor(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenRevokeOrphan operation middleware
func (siw *ServerInterfaceWrapper) TokenRevokeOrphan(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenRevokeOrphan(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenRevokeSelf operation middleware
func (siw *ServerInterfaceWrapper) TokenRevokeSelf(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenRevokeSelf(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenListRoles operation middleware
func (siw *ServerInterfaceWrapper) TokenListRoles(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TokenListRolesParams

	// ------------- Required query parameter "list" -------------

	if paramValue := r.URL.Query().Get("list"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "list"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "list", r.URL.Query(), &params.List)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "list", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenListRoles(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenDeleteRole operation middleware
func (siw *ServerInterfaceWrapper) TokenDeleteRole(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "role_name" -------------
	var roleName string

	err = runtime.BindStyledParameterWithOptions("simple", "role_name", chi.URLParam(r, "role_name"), &roleName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role_name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenDeleteRole(w, r, roleName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenReadRole operation middleware
func (siw *ServerInterfaceWrapper) TokenReadRole(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "role_name" -------------
	var roleName string

	err = runtime.BindStyledParameterWithOptions("simple", "role_name", chi.URLParam(r, "role_name"), &roleName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role_name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenReadRole(w, r, roleName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenWriteRole operation middleware
func (siw *ServerInterfaceWrapper) TokenWriteRole(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "role_name" -------------
	var roleName string

	err = runtime.BindStyledParameterWithOptions("simple", "role_name", chi.URLParam(r, "role_name"), &roleName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role_name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenWriteRole(w, r, roleName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2ReadConfiguration operation middleware
func (siw *ServerInterfaceWrapper) KvV2ReadConfiguration(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2ReadConfiguration(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2Configure operation middleware
func (siw *ServerInterfaceWrapper) KvV2Configure(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2Configure(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2Delete operation middleware
func (siw *ServerInterfaceWrapper) KvV2Delete(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2Delete(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2Read operation middleware
func (siw *ServerInterfaceWrapper) KvV2Read(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2Read(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2Write operation middleware
func (siw *ServerInterfaceWrapper) KvV2Write(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2Write(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2DeleteVersions operation middleware
func (siw *ServerInterfaceWrapper) KvV2DeleteVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2DeleteVersions(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2DestroyVersions operation middleware
func (siw *ServerInterfaceWrapper) KvV2DestroyVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2DestroyVersions(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2DeleteMetadataAndAllVersions operation middleware
func (siw *ServerInterfaceWrapper) KvV2DeleteMetadataAndAllVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2DeleteMetadataAndAllVersions(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2ReadMetadata operation middleware
func (siw *ServerInterfaceWrapper) KvV2ReadMetadata(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2ReadMetadata(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2WriteMetadata operation middleware
func (siw *ServerInterfaceWrapper) KvV2WriteMetadata(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2WriteMetadata(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2List operation middleware
func (siw *ServerInterfaceWrapper) KvV2List(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params KvV2ListParams

	// ------------- Required query parameter "list" -------------

	if paramValue := r.URL.Query().Get("list"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "list"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "list", r.URL.Query(), &params.List)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "list", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2List(w, r, path, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2ReadSubkeys operation middleware
func (siw *ServerInterfaceWrapper) KvV2ReadSubkeys(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2ReadSubkeys(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// KvV2UndeleteVersions operation middleware
func (siw *ServerInterfaceWrapper) KvV2UndeleteVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.KvV2UndeleteVersions(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthListEnabledMethods operation middleware
func (siw *ServerInterfaceWrapper) AuthListEnabledMethods(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthListEnabledMethods(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthDisableMethod operation middleware
func (siw *ServerInterfaceWrapper) AuthDisableMethod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthDisableMethod(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthReadConfiguration operation middleware
func (siw *ServerInterfaceWrapper) AuthReadConfiguration(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthReadConfiguration(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthEnableMethod operation middleware
func (siw *ServerInterfaceWrapper) AuthEnableMethod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", chi.URLParam(r, "path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthEnableMethod(w, r, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DecodeToken operation middleware
func (siw *ServerInterfaceWrapper) DecodeToken(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DecodeToken(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadHealthStatus operation middleware
func (siw *ServerInterfaceWrapper) ReadHealthStatus(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadHealthStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CollectHostInformation operation middleware
func (siw *ServerInterfaceWrapper) CollectHostInformation(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CollectHostInformation(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofIndex operation middleware
func (siw *ServerInterfaceWrapper) PprofIndex(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofIndex(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofMemoryAllocations operation middleware
func (siw *ServerInterfaceWrapper) PprofMemoryAllocations(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofMemoryAllocations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofBlocking operation middleware
func (siw *ServerInterfaceWrapper) PprofBlocking(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofBlocking(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofCommandLine operation middleware
func (siw *ServerInterfaceWrapper) PprofCommandLine(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofCommandLine(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofGoroutines operation middleware
func (siw *ServerInterfaceWrapper) PprofGoroutines(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofGoroutines(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofMemoryAllocationsLive operation middleware
func (siw *ServerInterfaceWrapper) PprofMemoryAllocationsLive(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofMemoryAllocationsLive(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofMutexes operation middleware
func (siw *ServerInterfaceWrapper) PprofMutexes(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofMutexes(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofCpuProfile operation middleware
func (siw *ServerInterfaceWrapper) PprofCpuProfile(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofCpuProfile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofSymbols operation middleware
func (siw *ServerInterfaceWrapper) PprofSymbols(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofSymbols(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofThreadCreations operation middleware
func (siw *ServerInterfaceWrapper) PprofThreadCreations(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofThreadCreations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PprofExecutionTrace operation middleware
func (siw *ServerInterfaceWrapper) PprofExecutionTrace(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PprofExecutionTrace(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Seal operation middleware
func (siw *ServerInterfaceWrapper) Seal(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Seal(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SealStatus operation middleware
func (siw *ServerInterfaceWrapper) SealStatus(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SealStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateHash operation middleware
func (siw *ServerInterfaceWrapper) GenerateHash(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateHash(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateHashWithAlgorithm operation middleware
func (siw *ServerInterfaceWrapper) GenerateHashWithAlgorithm(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "urlalgorithm" -------------
	var urlalgorithm string

	err = runtime.BindStyledParameterWithOptions("simple", "urlalgorithm", chi.URLParam(r, "urlalgorithm"), &urlalgorithm, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "urlalgorithm", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateHashWithAlgorithm(w, r, urlalgorithm)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateRandom operation middleware
func (siw *ServerInterfaceWrapper) GenerateRandom(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateRandom(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateRandomWithSource operation middleware
func (siw *ServerInterfaceWrapper) GenerateRandomWithSource(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "source" -------------
	var source string

	err = runtime.BindStyledParameterWithOptions("simple", "source", chi.URLParam(r, "source"), &source, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateRandomWithSource(w, r, source)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateRandomWithSourceAndBytes operation middleware
func (siw *ServerInterfaceWrapper) GenerateRandomWithSourceAndBytes(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "source" -------------
	var source string

	err = runtime.BindStyledParameterWithOptions("simple", "source", chi.URLParam(r, "source"), &source, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	// ------------- Path parameter "urlbytes" -------------
	var urlbytes string

	err = runtime.BindStyledParameterWithOptions("simple", "urlbytes", chi.URLParam(r, "urlbytes"), &urlbytes, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "urlbytes", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateRandomWithSourceAndBytes(w, r, source, urlbytes)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateRandomWithBytes operation middleware
func (siw *ServerInterfaceWrapper) GenerateRandomWithBytes(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "urlbytes" -------------
	var urlbytes string

	err = runtime.BindStyledParameterWithOptions("simple", "urlbytes", chi.URLParam(r, "urlbytes"), &urlbytes, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "urlbytes", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateRandomWithBytes(w, r, urlbytes)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Unseal operation middleware
func (siw *ServerInterfaceWrapper) Unseal(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Unseal(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/token/accessors/", wrapper.TokenListAccessors)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/create", wrapper.TokenCreate)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/create-orphan", wrapper.TokenCreateOrphan)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/create/{role_name}", wrapper.TokenCreateAgainstRole)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/token/lookup", wrapper.TokenLookUp2)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/lookup", wrapper.TokenLookUp)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/lookup-accessor", wrapper.TokenLookUpAccessor)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/token/lookup-self", wrapper.TokenLookUpSelf)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/lookup-self", wrapper.TokenLookUpSelf2)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/renew", wrapper.TokenRenew)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/renew-accessor", wrapper.TokenRenewAccessor)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/renew-self", wrapper.TokenRenewSelf)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/revoke", wrapper.TokenRevoke)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/revoke-accessor", wrapper.TokenRevokeAccessor)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/revoke-orphan", wrapper.TokenRevokeOrphan)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/revoke-self", wrapper.TokenRevokeSelf)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/token/roles/", wrapper.TokenListRoles)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/token/roles/{role_name}", wrapper.TokenDeleteRole)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/token/roles/{role_name}", wrapper.TokenReadRole)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token/roles/{role_name}", wrapper.TokenWriteRole)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/secret/config", wrapper.KvV2ReadConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/secret/config", wrapper.KvV2Configure)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/secret/data/{path}", wrapper.KvV2Delete)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/secret/data/{path}", wrapper.KvV2Read)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/secret/data/{path}", wrapper.KvV2Write)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/secret/delete/{path}", wrapper.KvV2DeleteVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/secret/destroy/{path}", wrapper.KvV2DestroyVersions)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/secret/metadata/{path}", wrapper.KvV2DeleteMetadataAndAllVersions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/secret/metadata/{path}", wrapper.KvV2ReadMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/secret/metadata/{path}", wrapper.KvV2WriteMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/secret/metadata/{path}/", wrapper.KvV2List)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/secret/subkeys/{path}", wrapper.KvV2ReadSubkeys)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/secret/undelete/{path}", wrapper.KvV2UndeleteVersions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/auth", wrapper.AuthListEnabledMethods)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/sys/auth/{path}", wrapper.AuthDisableMethod)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/auth/{path}", wrapper.AuthReadConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/auth/{path}", wrapper.AuthEnableMethod)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/decode-token", wrapper.DecodeToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/health", wrapper.ReadHealthStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/host-info", wrapper.CollectHostInformation)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof", wrapper.PprofIndex)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/allocs", wrapper.PprofMemoryAllocations)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/block", wrapper.PprofBlocking)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/cmdline", wrapper.PprofCommandLine)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/goroutine", wrapper.PprofGoroutines)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/heap", wrapper.PprofMemoryAllocationsLive)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/mutex", wrapper.PprofMutexes)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/profile", wrapper.PprofCpuProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/symbol", wrapper.PprofSymbols)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/threadcreate", wrapper.PprofThreadCreations)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/pprof/trace", wrapper.PprofExecutionTrace)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/seal", wrapper.Seal)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sys/seal-status", wrapper.SealStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/tools/hash", wrapper.GenerateHash)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/tools/hash/{urlalgorithm}", wrapper.GenerateHashWithAlgorithm)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/tools/random", wrapper.GenerateRandom)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/tools/random/{source}", wrapper.GenerateRandomWithSource)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/tools/random/{source}/{urlbytes}", wrapper.GenerateRandomWithSourceAndBytes)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/tools/random/{urlbytes}", wrapper.GenerateRandomWithBytes)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sys/unseal", wrapper.Unseal)
	})

	return r
}